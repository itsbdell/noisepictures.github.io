<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Hot Wheels: Blaze Rally</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body { width: 100%; height: 100%; overflow: hidden; background: #000; touch-action: none; }
canvas { display: block; image-rendering: pixelated; image-rendering: crisp-edges; }
#ui-overlay {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  pointer-events: none; z-index: 10;
}
#speed-display {
  position: fixed; bottom: 16px; left: 50%; transform: translateX(-50%);
  color: #ff6600; font-family: monospace; font-size: 18px; font-weight: bold;
  text-shadow: 0 0 6px #ff3300; z-index: 11; pointer-events: none;
  letter-spacing: 2px;
}
#lap-display {
  position: fixed; top: 12px; right: 16px;
  color: #ffcc00; font-family: monospace; font-size: 16px; font-weight: bold;
  text-shadow: 0 0 6px #ff9900; z-index: 11; pointer-events: none;
}
#time-display {
  position: fixed; top: 12px; left: 16px;
  color: #00ccff; font-family: monospace; font-size: 16px; font-weight: bold;
  text-shadow: 0 0 6px #0066ff; z-index: 11; pointer-events: none;
}
#position-display {
  position: fixed; top: 36px; left: 16px;
  color: #ff44ff; font-family: monospace; font-size: 14px; font-weight: bold;
  text-shadow: 0 0 6px #cc00cc; z-index: 11; pointer-events: none;
}
#start-screen {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: linear-gradient(180deg, #000022 0%, #110033 50%, #220011 100%);
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  z-index: 100; cursor: pointer;
}
#start-screen h1 {
  font-family: monospace; font-size: clamp(28px, 7vw, 56px); color: #ff6600;
  text-shadow: 0 0 20px #ff3300, 0 0 40px #ff0000, 3px 3px 0 #cc3300;
  letter-spacing: 4px; margin-bottom: 8px; text-align: center;
}
#start-screen h2 {
  font-family: monospace; font-size: clamp(16px, 4vw, 28px); color: #ffcc00;
  text-shadow: 0 0 10px #ff9900; margin-bottom: 40px;
}
#start-screen .tap-msg {
  font-family: monospace; font-size: clamp(14px, 3.5vw, 20px); color: #88aaff;
  animation: blink 1.2s infinite;
}
#start-screen .controls-info {
  font-family: monospace; font-size: clamp(11px, 2.8vw, 14px); color: #667799;
  margin-top: 24px; text-align: center; line-height: 1.8;
}
@keyframes blink { 0%,100% { opacity: 1; } 50% { opacity: 0.3; } }
#game-over-screen {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: rgba(0,0,0,0.85);
  display: none; flex-direction: column; align-items: center; justify-content: center;
  z-index: 100; cursor: pointer;
}
#game-over-screen h1 {
  font-family: monospace; font-size: clamp(24px, 6vw, 48px); color: #ffcc00;
  text-shadow: 0 0 20px #ff9900; margin-bottom: 12px;
}
#game-over-screen .stats {
  font-family: monospace; font-size: clamp(14px, 3.5vw, 20px); color: #aaccff;
  text-align: center; line-height: 2;
}
#game-over-screen .tap-msg {
  font-family: monospace; font-size: clamp(13px, 3vw, 18px); color: #88aaff;
  animation: blink 1.2s infinite; margin-top: 30px;
}
</style>
</head>
<body>

<div id="start-screen">
  <h1>HOT WHEELS</h1>
  <h2>BLAZE RALLY</h2>
  <div class="tap-msg">TAP TO RACE</div>
  <div class="controls-info">
    TILT or TOUCH left/right to STEER<br>
    TAP right side to BOOST<br>
    3 LAPS TO WIN
  </div>
</div>

<div id="game-over-screen">
  <h1 id="go-title">RACE COMPLETE!</h1>
  <div class="stats" id="go-stats"></div>
  <div class="tap-msg">TAP TO RACE AGAIN</div>
</div>

<canvas id="game"></canvas>
<div id="speed-display"></div>
<div id="lap-display"></div>
<div id="time-display"></div>
<div id="position-display"></div>

<script>
// ===== GAME CONFIG =====
const TOTAL_LAPS = 3;
const ROAD_W = 2200;
const SEG_LEN = 200;
const DRAW_DIST = 120;
const TRACK_LENGTH = 600; // segments
const NUM_RIVALS = 3;

// ===== CANVAS SETUP =====
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// ===== 16-BIT PALETTE =====
const PAL = {
  sky1: '#1a0a2e', sky2: '#16213e', sky3: '#0f3460',
  mount1: '#2d1b69', mount2: '#1b1464',
  grass1: '#1a7a1a', grass2: '#147014',
  road1: '#444444', road2: '#3a3a3a',
  rumble1: '#ff0000', rumble2: '#ffffff',
  lane: '#ffffff',
  startLine: '#ffcc00',
};

// ===== TRACK GENERATION =====
const segments = [];

function buildTrack() {
  segments.length = 0;
  for (let i = 0; i < TRACK_LENGTH; i++) {
    let curve = 0;
    let hill = 0;
    // Gentle S-curves
    if (i > 20 && i < 60) curve = 3.5;
    if (i > 80 && i < 120) curve = -4.0;
    if (i > 150 && i < 200) curve = 5.0;
    if (i > 220 && i < 260) curve = -3.0;
    if (i > 280 && i < 330) curve = 2.5;
    if (i > 350 && i < 400) curve = -5.0;
    if (i > 420 && i < 470) curve = 3.0;
    if (i > 490 && i < 540) curve = -2.5;
    if (i > 560 && i < 590) curve = 4.0;

    // Hills
    if (i > 40 && i < 70) hill = 25;
    if (i > 100 && i < 130) hill = -20;
    if (i > 180 && i < 210) hill = 30;
    if (i > 300 && i < 340) hill = -15;
    if (i > 400 && i < 440) hill = 20;
    if (i > 500 && i < 530) hill = -25;

    segments.push({
      index: i,
      p: { world: { x: 0, y: 0, z: i * SEG_LEN }, screen: {}, w: 0 },
      curve: curve,
      hill: hill,
      color: {}
    });
  }

  // Calculate world coordinates
  let x = 0, y = 0;
  for (let i = 0; i < TRACK_LENGTH; i++) {
    segments[i].p.world.x = x;
    segments[i].p.world.y = y;
    x += segments[i].curve;
    y += segments[i].hill;
  }
}

// ===== PLAYER STATE =====
let player = {};
let rivals = [];
let gameState = 'start'; // start, countdown, racing, finished
let countdownTimer = 0;
let countdownNum = 3;
let raceTime = 0;

function resetGame() {
  player = {
    x: 0,        // lateral position (-1 to 1)
    z: 0,        // distance along track
    speed: 0,
    maxSpeed: SEG_LEN * 65,
    accel: SEG_LEN * 18,
    brake: SEG_LEN * 30,
    decel: SEG_LEN * 8,
    turnSpeed: 4.5,
    boosting: false,
    boostFuel: 100,
    boostTimer: 0,
    lap: 0,
    lapZ: 0,       // z when last lap was counted
    prevSegIndex: 0,
    steer: 0,
  };

  // Create rival cars
  rivals = [];
  const rivalColors = ['#3366ff', '#33cc33', '#ff33ff'];
  const rivalSpeeds = [0.82, 0.72, 0.62];
  for (let i = 0; i < NUM_RIVALS; i++) {
    rivals.push({
      x: -0.5 + (i * 0.5),
      z: 0,
      speed: 0,
      targetSpeed: player.maxSpeed * rivalSpeeds[i],
      color: rivalColors[i],
      lap: 0,
      prevSegIndex: 0,
      wobble: Math.random() * Math.PI * 2,
      finished: false,
    });
  }

  raceTime = 0;
}

// ===== FIRE PARTICLE SYSTEM =====
const fireParticles = [];

function spawnFire(screenX, screenY, scale, intensity) {
  const count = Math.floor(intensity * 3);
  for (let i = 0; i < count; i++) {
    fireParticles.push({
      x: screenX + (Math.random() - 0.5) * 8 * scale,
      y: screenY,
      vx: (Math.random() - 0.5) * 2 * scale,
      vy: -(1 + Math.random() * 3) * scale,
      life: 0.4 + Math.random() * 0.4,
      maxLife: 0.4 + Math.random() * 0.4,
      size: (2 + Math.random() * 4) * scale,
    });
  }
}

function updateFire(dt) {
  for (let i = fireParticles.length - 1; i >= 0; i--) {
    const p = fireParticles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.life -= dt;
    p.size *= 0.97;
    if (p.life <= 0) fireParticles.splice(i, 1);
  }
}

function drawFire() {
  for (const p of fireParticles) {
    const t = p.life / p.maxLife;
    let r, g, b;
    if (t > 0.6) {
      r = 255; g = 255; b = 100 + (1 - t) * 155;
    } else if (t > 0.3) {
      r = 255; g = Math.floor(100 + t * 255); b = 0;
    } else {
      r = Math.floor(180 + t * 75); g = Math.floor(t * 100); b = 0;
    }
    ctx.globalAlpha = Math.min(1, t * 2);
    ctx.fillStyle = `rgb(${r},${g},${b})`;
    ctx.fillRect(Math.floor(p.x - p.size/2), Math.floor(p.y - p.size/2),
                 Math.ceil(p.size), Math.ceil(p.size));
  }
  ctx.globalAlpha = 1;
}

// ===== EXHAUST / SMOKE PARTICLES =====
const smokeParticles = [];

function spawnSmoke(screenX, screenY, scale) {
  smokeParticles.push({
    x: screenX + (Math.random() - 0.5) * 4,
    y: screenY,
    vx: (Math.random() - 0.5) * 1.5,
    vy: -(0.5 + Math.random() * 1.5) * scale,
    life: 0.5 + Math.random() * 0.5,
    maxLife: 0.5 + Math.random() * 0.5,
    size: (3 + Math.random() * 3) * scale,
  });
}

function updateSmoke(dt) {
  for (let i = smokeParticles.length - 1; i >= 0; i--) {
    const p = smokeParticles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.life -= dt;
    p.size *= 1.01;
    if (p.life <= 0) smokeParticles.splice(i, 1);
  }
}

function drawSmoke() {
  for (const p of smokeParticles) {
    const t = p.life / p.maxLife;
    const a = Math.floor(80 * t);
    ctx.globalAlpha = t * 0.4;
    ctx.fillStyle = `rgb(${120+a},${120+a},${120+a})`;
    ctx.fillRect(Math.floor(p.x - p.size/2), Math.floor(p.y - p.size/2),
                 Math.ceil(p.size), Math.ceil(p.size));
  }
  ctx.globalAlpha = 1;
}

// ===== STAR FIELD =====
const stars = [];
for (let i = 0; i < 80; i++) {
  stars.push({
    x: Math.random(),
    y: Math.random() * 0.35,
    size: 1 + Math.random() * 2,
    twinkle: Math.random() * Math.PI * 2,
  });
}

// ===== INPUT HANDLING =====
const keys = { left: false, right: false, up: false, down: false, boost: false };
let touchSteerX = 0;
let isTouching = false;
let touchBoost = false;
let useGyro = false;
let gyroX = 0;

document.addEventListener('keydown', e => {
  if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = true;
  if (e.key === 'ArrowRight' || e.key === 'd') keys.right = true;
  if (e.key === 'ArrowUp' || e.key === 'w') keys.up = true;
  if (e.key === 'ArrowDown' || e.key === 's') keys.down = true;
  if (e.key === ' ' || e.key === 'Shift') keys.boost = true;
});
document.addEventListener('keyup', e => {
  if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = false;
  if (e.key === 'ArrowRight' || e.key === 'd') keys.right = false;
  if (e.key === 'ArrowUp' || e.key === 'w') keys.up = false;
  if (e.key === 'ArrowDown' || e.key === 's') keys.down = false;
  if (e.key === ' ' || e.key === 'Shift') keys.boost = false;
});

// Touch controls
canvas.addEventListener('touchstart', handleTouch, { passive: false });
canvas.addEventListener('touchmove', handleTouch, { passive: false });
canvas.addEventListener('touchend', e => {
  e.preventDefault();
  isTouching = false;
  touchBoost = false;
  touchSteerX = 0;
}, { passive: false });

function handleTouch(e) {
  e.preventDefault();
  isTouching = true;
  const touches = e.touches;
  touchSteerX = 0;
  touchBoost = false;

  for (let i = 0; i < touches.length; i++) {
    const tx = touches[i].clientX / window.innerWidth;
    if (tx < 0.4) {
      touchSteerX = -1;
    } else if (tx > 0.6) {
      if (tx > 0.85) {
        touchBoost = true;
      } else {
        touchSteerX = 1;
      }
    }
  }
}

// Gyroscope (tilt steering)
if (window.DeviceOrientationEvent) {
  window.addEventListener('deviceorientation', e => {
    if (e.gamma !== null) {
      useGyro = true;
      gyroX = e.gamma / 30; // normalize tilt
      gyroX = Math.max(-1, Math.min(1, gyroX));
    }
  });
}

// ===== PROJECTION =====
function project(p, camX, camY, camZ, camDepth) {
  p.screen.scale = camDepth / (p.world.z - camZ);
  p.screen.x = (canvas.width / 2) + (p.screen.scale * (p.world.x - camX) * canvas.width / 2);
  p.screen.y = (canvas.height / 2) - (p.screen.scale * (p.world.y - camY) * canvas.height / 2);
  p.screen.w = p.screen.scale * ROAD_W * canvas.width / 2;
}

// ===== RENDERING =====
function drawSky() {
  const h = canvas.height;
  const grad = ctx.createLinearGradient(0, 0, 0, h * 0.5);
  grad.addColorStop(0, PAL.sky1);
  grad.addColorStop(0.5, PAL.sky2);
  grad.addColorStop(1, PAL.sky3);
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, canvas.width, h * 0.5);

  // Stars
  const time = performance.now() / 1000;
  for (const s of stars) {
    const twinkle = Math.sin(time * 2 + s.twinkle) * 0.5 + 0.5;
    ctx.globalAlpha = 0.3 + twinkle * 0.7;
    ctx.fillStyle = '#fff';
    ctx.fillRect(Math.floor(s.x * canvas.width), Math.floor(s.y * h), Math.ceil(s.size), Math.ceil(s.size));
  }
  ctx.globalAlpha = 1;
}

function drawMountains(baseY) {
  const w = canvas.width;
  const time = player.z * 0.0001;

  // Far mountains
  ctx.fillStyle = PAL.mount1;
  ctx.beginPath();
  ctx.moveTo(0, baseY);
  for (let x = 0; x <= w; x += 4) {
    const h = Math.sin(x * 0.003 + time) * 40 + Math.sin(x * 0.007 + time * 0.5) * 25;
    ctx.lineTo(x, baseY - 60 - h);
  }
  ctx.lineTo(w, baseY);
  ctx.fill();

  // Near mountains
  ctx.fillStyle = PAL.mount2;
  ctx.beginPath();
  ctx.moveTo(0, baseY);
  for (let x = 0; x <= w; x += 4) {
    const h = Math.sin(x * 0.005 + time * 1.5) * 30 + Math.sin(x * 0.011 + time) * 20;
    ctx.lineTo(x, baseY - 35 - h);
  }
  ctx.lineTo(w, baseY);
  ctx.fill();
}

function drawSegment(x1, y1, w1, x2, y2, w2, color, idx) {
  // Grass
  ctx.fillStyle = (idx % 2 === 0) ? PAL.grass1 : PAL.grass2;
  ctx.fillRect(0, Math.floor(y2), canvas.width, Math.ceil(y1 - y2) + 1);

  // Road
  ctx.fillStyle = (idx % 2 === 0) ? PAL.road1 : PAL.road2;
  drawTrapezoid(x1, y1, w1, x2, y2, w2);

  // Rumble strips
  const rw1 = w1 * 1.15, rw2 = w2 * 1.15;
  ctx.fillStyle = (idx % 2 === 0) ? PAL.rumble1 : PAL.rumble2;
  drawTrapezoid(x1, y1, rw1, x2, y2, rw2);
  // Redraw road on top
  ctx.fillStyle = (idx % 2 === 0) ? PAL.road1 : PAL.road2;
  drawTrapezoid(x1, y1, w1, x2, y2, w2);

  // Lane markings
  if (idx % 4 < 2) {
    ctx.fillStyle = PAL.lane;
    const lw1 = w1 * 0.01, lw2 = w2 * 0.01;
    // Left lane
    drawTrapezoid(x1 - w1 * 0.33, y1, lw1, x2 - w2 * 0.33, y2, lw2);
    // Right lane
    drawTrapezoid(x1 + w1 * 0.33, y1, lw1, x2 + w2 * 0.33, y2, lw2);
  }

  // Start/finish line
  const segIdx = idx % TRACK_LENGTH;
  if (segIdx === 0 || segIdx === 1) {
    ctx.fillStyle = PAL.startLine;
    ctx.globalAlpha = 0.6;
    drawTrapezoid(x1, y1, w1 * 0.95, x2, y2, w2 * 0.95);
    ctx.globalAlpha = 1;
    // Checkerboard
    const checks = 10;
    for (let c = 0; c < checks; c++) {
      if ((c + (segIdx % 2)) % 2 === 0) {
        ctx.fillStyle = '#000';
        const cx1 = x1 - w1 * 0.9 + (c / checks) * w1 * 1.8;
        const cx2 = x2 - w2 * 0.9 + (c / checks) * w2 * 1.8;
        const cw1 = w1 * 1.8 / checks;
        const cw2 = w2 * 1.8 / checks;
        drawTrapezoid(cx1 + cw1*0.5, y1, cw1*0.5, cx2 + cw2*0.5, y2, cw2*0.5);
      }
    }
  }
}

function drawTrapezoid(x1, y1, w1, x2, y2, w2) {
  ctx.beginPath();
  ctx.moveTo(x1 - w1, y1);
  ctx.lineTo(x1 + w1, y1);
  ctx.lineTo(x2 + w2, y2);
  ctx.lineTo(x2 - w2, y2);
  ctx.fill();
}

// ===== DRAW 16-BIT PIXEL CAR =====
function drawCar(cx, cy, scale, color, isPlayer, speed, boosting) {
  const s = scale * 1.3;
  const px = (v) => Math.floor(v);

  // Shadow
  ctx.globalAlpha = 0.3;
  ctx.fillStyle = '#000';
  ctx.fillRect(px(cx - 22*s), px(cy + 2*s), px(44*s), px(6*s));
  ctx.globalAlpha = 1;

  if (isPlayer) {
    // -- PLAYER CAR: Hot Wheels style muscle car --
    // Main body (orange-red hot wheels color)
    ctx.fillStyle = '#ff4400';
    ctx.fillRect(px(cx - 18*s), px(cy - 14*s), px(36*s), px(10*s));

    // Hood (front)
    ctx.fillStyle = '#ff5500';
    ctx.fillRect(px(cx - 14*s), px(cy - 10*s), px(28*s), px(4*s));

    // Windshield
    ctx.fillStyle = '#4488cc';
    ctx.fillRect(px(cx - 10*s), px(cy - 18*s), px(20*s), px(5*s));

    // Roof
    ctx.fillStyle = '#cc3300';
    ctx.fillRect(px(cx - 8*s), px(cy - 20*s), px(16*s), px(3*s));

    // Flame decal on sides
    ctx.fillStyle = '#ffaa00';
    ctx.fillRect(px(cx - 18*s), px(cy - 12*s), px(8*s), px(2*s));
    ctx.fillRect(px(cx + 10*s), px(cy - 12*s), px(8*s), px(2*s));
    ctx.fillStyle = '#ffcc00';
    ctx.fillRect(px(cx - 16*s), px(cy - 10*s), px(5*s), px(2*s));
    ctx.fillRect(px(cx + 11*s), px(cy - 10*s), px(5*s), px(2*s));

    // Hot Wheels stripe
    ctx.fillStyle = '#ffcc00';
    ctx.fillRect(px(cx - 2*s), px(cy - 14*s), px(4*s), px(10*s));

    // Headlights
    ctx.fillStyle = '#ffffaa';
    ctx.fillRect(px(cx - 16*s), px(cy - 6*s), px(4*s), px(3*s));
    ctx.fillRect(px(cx + 12*s), px(cy - 6*s), px(4*s), px(3*s));

    // Wheels (big, chunky)
    ctx.fillStyle = '#222';
    ctx.fillRect(px(cx - 20*s), px(cy - 4*s), px(8*s), px(8*s));
    ctx.fillRect(px(cx + 12*s), px(cy - 4*s), px(8*s), px(8*s));
    // Wheel rims
    ctx.fillStyle = '#999';
    ctx.fillRect(px(cx - 18*s), px(cy - 2*s), px(4*s), px(4*s));
    ctx.fillRect(px(cx + 14*s), px(cy - 2*s), px(4*s), px(4*s));
    // Wheel rim highlight
    ctx.fillStyle = '#ccc';
    ctx.fillRect(px(cx - 17*s), px(cy - 1*s), px(2*s), px(2*s));
    ctx.fillRect(px(cx + 15*s), px(cy - 1*s), px(2*s), px(2*s));

    // === FIRE FROM TIRES ===
    const intensity = Math.min(1, speed / (player.maxSpeed * 0.5));
    if (speed > player.maxSpeed * 0.1) {
      // Rear left tire fire
      spawnFire(cx - 16*s, cy + 4*s, s, intensity);
      // Rear right tire fire
      spawnFire(cx + 16*s, cy + 4*s, s, intensity);
    }

    // Boost exhaust fire (from center back)
    if (boosting) {
      spawnFire(cx, cy + 5*s, s * 1.5, 2);
      spawnFire(cx - 6*s, cy + 5*s, s * 1.2, 1.5);
      spawnFire(cx + 6*s, cy + 5*s, s * 1.2, 1.5);
    } else if (speed > 0) {
      spawnSmoke(cx, cy + 4*s, s);
    }

    // Boost glow effect
    if (boosting) {
      ctx.globalAlpha = 0.4 + Math.sin(performance.now() * 0.02) * 0.2;
      ctx.fillStyle = '#ff6600';
      ctx.fillRect(px(cx - 22*s), px(cy - 22*s), px(44*s), px(26*s));
      ctx.globalAlpha = 1;
    }

  } else {
    // -- RIVAL CAR --
    ctx.fillStyle = color;
    ctx.fillRect(px(cx - 16*s), px(cy - 12*s), px(32*s), px(9*s));
    // Windshield
    ctx.fillStyle = '#335577';
    ctx.fillRect(px(cx - 8*s), px(cy - 16*s), px(16*s), px(5*s));
    // Roof
    const r = parseInt(color.slice(1,3),16), g = parseInt(color.slice(3,5),16), b = parseInt(color.slice(5,7),16);
    ctx.fillStyle = `rgb(${Math.floor(r*0.7)},${Math.floor(g*0.7)},${Math.floor(b*0.7)})`;
    ctx.fillRect(px(cx - 6*s), px(cy - 18*s), px(12*s), px(3*s));
    // Wheels
    ctx.fillStyle = '#222';
    ctx.fillRect(px(cx - 18*s), px(cy - 3*s), px(7*s), px(7*s));
    ctx.fillRect(px(cx + 11*s), px(cy - 3*s), px(7*s), px(7*s));
    ctx.fillStyle = '#888';
    ctx.fillRect(px(cx - 16*s), px(cy - 1*s), px(3*s), px(3*s));
    ctx.fillRect(px(cx + 13*s), px(cy - 1*s), px(3*s), px(3*s));
    // Rival tire fire (less intense)
    if (speed > player.maxSpeed * 0.2) {
      const ri = Math.min(0.6, speed / player.maxSpeed);
      spawnFire(cx - 14*s, cy + 4*s, s * 0.7, ri);
      spawnFire(cx + 14*s, cy + 4*s, s * 0.7, ri);
    }
  }
}

// ===== RIVAL AI =====
function updateRivals(dt) {
  const trackLen = TRACK_LENGTH * SEG_LEN;
  for (const r of rivals) {
    if (r.finished) continue;

    // Accelerate to target speed with some variation
    r.wobble += dt * (1 + Math.random());
    const speedVar = 1 + Math.sin(r.wobble) * 0.08;
    const target = r.targetSpeed * speedVar;
    if (r.speed < target) {
      r.speed += player.accel * 0.6 * dt;
    } else {
      r.speed -= player.decel * 0.5 * dt;
    }
    r.speed = Math.max(0, Math.min(r.speed, player.maxSpeed * 0.95));

    // Steer to center with wobble
    const targetX = Math.sin(r.wobble * 0.3) * 0.4;
    r.x += (targetX - r.x) * dt * 1.5;
    r.x = Math.max(-0.9, Math.min(0.9, r.x));

    // Move
    const prevZ = r.z;
    r.z += r.speed * dt;

    // Lap counting
    const prevSeg = Math.floor(prevZ / SEG_LEN) % TRACK_LENGTH;
    const curSeg = Math.floor(r.z / SEG_LEN) % TRACK_LENGTH;
    if (prevSeg > TRACK_LENGTH * 0.9 && curSeg < TRACK_LENGTH * 0.1) {
      r.lap++;
      if (r.lap >= TOTAL_LAPS) r.finished = true;
    }

    if (r.z >= trackLen) r.z -= trackLen;
  }
}

// ===== POSITION TRACKING =====
function getPosition() {
  const trackLen = TRACK_LENGTH * SEG_LEN;
  const playerProgress = player.lap * trackLen + player.z;
  let pos = 1;
  for (const r of rivals) {
    const rivalProgress = r.lap * trackLen + r.z;
    if (rivalProgress > playerProgress) pos++;
  }
  return pos;
}

function positionSuffix(p) {
  if (p === 1) return '1st';
  if (p === 2) return '2nd';
  if (p === 3) return '3rd';
  return p + 'th';
}

// ===== UPDATE =====
function update(dt) {
  if (gameState === 'countdown') {
    countdownTimer -= dt;
    if (countdownTimer <= 0) {
      countdownNum--;
      countdownTimer = 1;
      if (countdownNum < 0) {
        gameState = 'racing';
      }
    }
    return;
  }

  if (gameState !== 'racing') return;

  raceTime += dt;

  const trackLen = TRACK_LENGTH * SEG_LEN;

  // Steering input
  let steer = 0;
  if (keys.left) steer = -1;
  if (keys.right) steer = 1;
  if (isTouching && touchSteerX !== 0) steer = touchSteerX;
  if (useGyro && !isTouching && !keys.left && !keys.right) steer = gyroX;

  // Auto-accelerate on mobile (always accelerating)
  const accelerating = keys.up || isTouching || useGyro || true; // always go forward
  const braking = keys.down;
  const wantBoost = keys.boost || touchBoost;

  // Boost logic
  player.boosting = false;
  if (wantBoost && player.boostFuel > 0 && player.speed > player.maxSpeed * 0.3) {
    player.boosting = true;
    player.boostFuel -= dt * 40;
    if (player.boostFuel < 0) player.boostFuel = 0;
  } else {
    player.boostFuel = Math.min(100, player.boostFuel + dt * 8);
  }

  // Acceleration
  const topSpeed = player.boosting ? player.maxSpeed * 1.35 : player.maxSpeed;
  if (accelerating && !braking) {
    const accelRate = player.boosting ? player.accel * 2.2 : player.accel;
    player.speed += accelRate * dt;
  }
  if (braking) {
    player.speed -= player.brake * dt;
  }
  if (!accelerating && !braking) {
    player.speed -= player.decel * dt;
  }
  player.speed = Math.max(0, Math.min(player.speed, topSpeed));

  // Off-road slowdown
  if (Math.abs(player.x) > 0.85) {
    player.speed *= (1 - 0.03);
    // Dirt particles
    if (player.speed > 100) {
      for (let i = 0; i < 2; i++) {
        smokeParticles.push({
          x: canvas.width/2 + (Math.random()-0.5)*40,
          y: canvas.height * 0.72,
          vx: (Math.random()-0.5)*3,
          vy: -(Math.random()*2),
          life: 0.3, maxLife: 0.3,
          size: 3 + Math.random()*4,
        });
      }
    }
  }

  // Curve influence on car
  const segIdx = Math.floor(player.z / SEG_LEN) % TRACK_LENGTH;
  const curve = segments[segIdx].curve;
  player.x -= curve * (player.speed / player.maxSpeed) * dt * 0.6;

  // Player steering
  if (player.speed > 0) {
    player.x += steer * player.turnSpeed * dt * (player.speed / player.maxSpeed);
  }
  player.x = Math.max(-1.8, Math.min(1.8, player.x));
  player.steer = steer;

  // Move forward
  const prevZ = player.z;
  player.z += player.speed * dt;

  // Lap counting
  const prevSeg = Math.floor(prevZ / SEG_LEN) % TRACK_LENGTH;
  const curSeg = Math.floor(player.z / SEG_LEN) % TRACK_LENGTH;
  if (prevSeg > TRACK_LENGTH * 0.9 && curSeg < TRACK_LENGTH * 0.1) {
    player.lap++;
    if (player.lap >= TOTAL_LAPS) {
      gameState = 'finished';
      showGameOver();
    }
  }

  if (player.z >= trackLen) player.z -= trackLen;

  // Rival collision avoidance with player
  for (const r of rivals) {
    const dz = Math.abs(r.z - player.z);
    const dx = Math.abs(r.x - player.x);
    if (dz < SEG_LEN * 2 && dx < 0.4) {
      // Bump effect
      if (r.x < player.x) {
        r.x -= 0.02;
        player.x += 0.01;
      } else {
        r.x += 0.02;
        player.x -= 0.01;
      }
      player.speed *= 0.98;
    }
  }

  updateRivals(dt);
  updateFire(dt);
  updateSmoke(dt);
}

// ===== RENDER =====
function render() {
  const w = canvas.width;
  const h = canvas.height;

  // Clear
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, w, h);

  drawSky();

  const baseSegIdx = Math.floor(player.z / SEG_LEN);
  const camH = 1200;
  const camDepth = 1 / Math.tan((80 / 2) * Math.PI / 180);

  // Find base segment y
  const baseSeg = segments[baseSegIdx % TRACK_LENGTH];
  const camY = baseSeg.p.world.y + camH;
  const camZ = player.z - camDepth * SEG_LEN;

  let maxY = h;
  let baseScreenY = h;

  // Project and draw road segments (back to front)
  const projectedSegs = [];
  let cumCurveX = 0;

  for (let n = 0; n < DRAW_DIST; n++) {
    const idx = (baseSegIdx + n) % TRACK_LENGTH;
    const seg = segments[idx];
    const worldZ = (baseSegIdx + n) * SEG_LEN;

    // Use accumulated curve for x offset
    const pCopy = {
      world: {
        x: seg.p.world.x + cumCurveX - player.x * ROAD_W,
        y: seg.p.world.y,
        z: worldZ,
      },
      screen: {},
    };

    const relZ = pCopy.world.z - camZ;
    if (relZ <= 0) continue;

    pCopy.screen.scale = camDepth / (relZ / SEG_LEN);
    pCopy.screen.x = w/2 + (pCopy.screen.scale * (pCopy.world.x) * w / 2) / (ROAD_W);
    pCopy.screen.y = h/2 - (pCopy.screen.scale * (pCopy.world.y - camY) * h / 2) / camH;
    pCopy.screen.w = pCopy.screen.scale * ROAD_W * w / (2 * ROAD_W) * 1.2;

    cumCurveX += seg.curve * 2;

    projectedSegs.push({
      idx: idx,
      n: n,
      screen: pCopy.screen,
      worldZ: worldZ,
    });
  }

  // Draw mountains at horizon
  if (projectedSegs.length > 0) {
    const horizonY = projectedSegs[projectedSegs.length - 1].screen.y;
    drawMountains(Math.min(h * 0.5, horizonY));
  }

  // Draw segments back to front
  for (let i = projectedSegs.length - 1; i > 0; i--) {
    const s0 = projectedSegs[i];
    const s1 = projectedSegs[i - 1];

    if (s0.screen.y >= maxY) continue;

    drawSegment(
      s1.screen.x, s1.screen.y, s1.screen.w,
      s0.screen.x, s0.screen.y, s0.screen.w,
      null, s0.idx
    );

    maxY = Math.min(maxY, s0.screen.y);
  }

  // Draw rival cars
  const allCars = [];
  const trackLen = TRACK_LENGTH * SEG_LEN;
  for (const r of rivals) {
    let dz = r.z - player.z;
    if (dz < -trackLen/2) dz += trackLen;
    if (dz > trackLen/2) dz -= trackLen;
    if (dz > 0 && dz < SEG_LEN * DRAW_DIST) {
      allCars.push({ ...r, dz: dz, isPlayer: false });
    }
  }

  // Sort by distance (far first)
  allCars.sort((a, b) => b.dz - a.dz);

  for (const car of allCars) {
    // Find projected position
    const n = car.dz / SEG_LEN;
    const i = Math.floor(n);
    if (i >= projectedSegs.length - 1 || i < 0) continue;

    // Find matching projected segment
    let ps = null;
    for (const p of projectedSegs) {
      if (p.n === i) { ps = p; break; }
    }
    if (!ps) continue;

    const carX = ps.screen.x + (car.x * ps.screen.w * 0.7);
    const carY = ps.screen.y;
    const carScale = ps.screen.scale * 0.6;

    if (carScale > 0.01 && carY < h && carY > 0) {
      drawCar(carX, carY, carScale, car.color, false, car.speed, false);
    }
  }

  // Draw player car
  const playerY = h * 0.72;
  const playerScale = 1.4;
  const playerScreenX = w/2 + (player.steer * 15);
  drawCar(playerScreenX, playerY, playerScale, '#ff4400', true, player.speed, player.boosting);

  // Draw fire & smoke
  drawFire();
  drawSmoke();

  // Boost meter
  const bx = w - 40, by = h * 0.35, bh = h * 0.3;
  ctx.globalAlpha = 0.5;
  ctx.fillStyle = '#222';
  ctx.fillRect(bx, by, 20, bh);
  ctx.globalAlpha = 0.8;
  const fuel = player.boostFuel / 100;
  const fuelColor = player.boosting ? '#ff4400' : '#ff8800';
  ctx.fillStyle = fuelColor;
  ctx.fillRect(bx, by + bh * (1 - fuel), 20, bh * fuel);
  ctx.globalAlpha = 1;
  ctx.strokeStyle = '#666';
  ctx.lineWidth = 1;
  ctx.strokeRect(bx, by, 20, bh);
  ctx.fillStyle = '#fff';
  ctx.font = '10px monospace';
  ctx.textAlign = 'center';
  ctx.fillText('NOS', bx + 10, by - 4);

  // Countdown
  if (gameState === 'countdown' && countdownNum > 0) {
    ctx.fillStyle = countdownNum === 1 ? '#00ff00' : '#ffcc00';
    ctx.font = `bold ${Math.min(120, w * 0.25)}px monospace`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.shadowColor = ctx.fillStyle;
    ctx.shadowBlur = 30;
    ctx.fillText(countdownNum, w/2, h/2);
    ctx.shadowBlur = 0;
  } else if (gameState === 'countdown' && countdownNum === 0) {
    ctx.fillStyle = '#00ff00';
    ctx.font = `bold ${Math.min(80, w * 0.18)}px monospace`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.shadowColor = '#00ff00';
    ctx.shadowBlur = 30;
    ctx.fillText('GO!', w/2, h/2);
    ctx.shadowBlur = 0;
  }

  // HUD
  const mph = Math.floor((player.speed / player.maxSpeed) * 220);
  document.getElementById('speed-display').textContent = mph + ' MPH';
  document.getElementById('lap-display').textContent = `LAP ${Math.min(player.lap + 1, TOTAL_LAPS)}/${TOTAL_LAPS}`;
  const mins = Math.floor(raceTime / 60);
  const secs = Math.floor(raceTime % 60);
  const ms = Math.floor((raceTime % 1) * 100);
  document.getElementById('time-display').textContent =
    `${String(mins).padStart(2,'0')}:${String(secs).padStart(2,'0')}.${String(ms).padStart(2,'0')}`;
  document.getElementById('position-display').textContent = positionSuffix(getPosition()) + ' PLACE';
}

// ===== GAME OVER =====
function showGameOver() {
  const goScreen = document.getElementById('game-over-screen');
  const pos = getPosition();
  const title = document.getElementById('go-title');
  const stats = document.getElementById('go-stats');

  if (pos === 1) {
    title.textContent = 'YOU WIN!';
    title.style.color = '#ffcc00';
  } else {
    title.textContent = 'RACE COMPLETE';
    title.style.color = '#aaaaff';
  }

  const mins = Math.floor(raceTime / 60);
  const secs = Math.floor(raceTime % 60);
  const ms = Math.floor((raceTime % 1) * 100);

  stats.innerHTML = `
    POSITION: ${positionSuffix(pos)}<br>
    TIME: ${String(mins).padStart(2,'0')}:${String(secs).padStart(2,'0')}.${String(ms).padStart(2,'0')}<br>
    TOP SPEED: ${Math.floor(1.35 * 220)} MPH
  `;

  goScreen.style.display = 'flex';
}

// ===== START / RESTART =====
function startGame() {
  document.getElementById('start-screen').style.display = 'none';
  document.getElementById('game-over-screen').style.display = 'none';
  fireParticles.length = 0;
  smokeParticles.length = 0;
  resetGame();
  buildTrack();
  gameState = 'countdown';
  countdownNum = 3;
  countdownTimer = 1;
}

document.getElementById('start-screen').addEventListener('click', startGame);
document.getElementById('start-screen').addEventListener('touchend', e => {
  e.preventDefault();
  startGame();
});

document.getElementById('game-over-screen').addEventListener('click', startGame);
document.getElementById('game-over-screen').addEventListener('touchend', e => {
  e.preventDefault();
  startGame();
});

// ===== GAME LOOP =====
let lastTime = 0;

function gameLoop(timestamp) {
  const dt = Math.min(0.05, (timestamp - lastTime) / 1000);
  lastTime = timestamp;

  update(dt);
  render();

  requestAnimationFrame(gameLoop);
}

// Init
buildTrack();
resetGame();
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
