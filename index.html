<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Hot Wheels: Road Trip!</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body { width: 100%; height: 100%; overflow: hidden; background: #000; touch-action: none; }
canvas { display: block; }
#start-screen {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: linear-gradient(180deg, #0a0a2e 0%, #1a0a3e 40%, #2a1020 100%);
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  z-index: 100; cursor: pointer;
}
#start-screen h1 {
  font-family: 'Arial Black', sans-serif; font-size: clamp(32px, 8vw, 64px); color: #ff6600;
  text-shadow: 0 0 20px #ff3300, 0 0 40px #ff0000, 3px 3px 0 #cc3300;
  letter-spacing: 3px; margin-bottom: 4px; text-align: center;
}
#start-screen h2 {
  font-family: 'Arial Black', sans-serif; font-size: clamp(18px, 5vw, 36px); color: #ffcc00;
  text-shadow: 0 0 10px #ff9900; margin-bottom: 30px;
}
#start-screen .level-preview {
  font-family: monospace; font-size: clamp(11px, 2.5vw, 15px); color: #88aacc;
  line-height: 2; text-align: center; margin-bottom: 24px;
}
#start-screen .tap-msg {
  font-family: monospace; font-size: clamp(16px, 4vw, 24px); color: #88aaff;
  animation: blink 1.2s infinite;
}
#start-screen .controls-info {
  font-family: monospace; font-size: clamp(11px, 2.5vw, 14px); color: #667799;
  margin-top: 20px; text-align: center; line-height: 1.8;
}
@keyframes blink { 0%,100% { opacity: 1; } 50% { opacity: 0.3; } }

#level-intro {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: rgba(0,0,0,0.9);
  display: none; flex-direction: column; align-items: center; justify-content: center;
  z-index: 100;
}
#level-intro h1 {
  font-family: 'Arial Black', sans-serif; font-size: clamp(20px, 5vw, 40px); color: #ffcc00;
  text-shadow: 0 0 15px #ff9900; margin-bottom: 8px; text-align: center;
}
#level-intro h2 {
  font-family: 'Arial Black', sans-serif; font-size: clamp(14px, 3.5vw, 26px); color: #ff8844;
  margin-bottom: 20px; text-align: center;
}
#level-intro .tap-msg {
  font-family: monospace; font-size: clamp(14px, 3vw, 18px); color: #88aaff;
  animation: blink 1.2s infinite;
}

#game-over-screen {
  position: fixed; top: 0; left: 0; width: 100%; height: 100%;
  background: rgba(0,0,0,0.88);
  display: none; flex-direction: column; align-items: center; justify-content: center;
  z-index: 100; cursor: pointer;
}
#game-over-screen h1 {
  font-family: 'Arial Black', sans-serif; font-size: clamp(28px, 7vw, 56px); color: #ffcc00;
  text-shadow: 0 0 20px #ff9900; margin-bottom: 12px;
}
#game-over-screen .stats {
  font-family: monospace; font-size: clamp(13px, 3vw, 18px); color: #aaccff;
  text-align: center; line-height: 2;
}
#game-over-screen .tap-msg {
  font-family: monospace; font-size: clamp(13px, 3vw, 18px); color: #88aaff;
  animation: blink 1.2s infinite; margin-top: 24px;
}
</style>
</head>
<body>

<div id="start-screen">
  <h1>HOT WHEELS</h1>
  <h2>ROAD TRIP!</h2>
  <div class="level-preview">
    LEVEL 1: Costa Rica → Airport<br>
    LEVEL 2: Airport → Plane Gate<br>
    LEVEL 3: NYC → Brooklyn Home
  </div>
  <div class="tap-msg">TAP TO PLAY</div>
  <div class="controls-info">
    TAP / SPACE to JUMP<br>
    HOLD / SHIFT for BOOST<br>
    Endless lives — just jump &amp; boost!
  </div>
</div>

<div id="level-intro">
  <h1 id="level-title"></h1>
  <h2 id="level-subtitle"></h2>
  <div class="tap-msg">TAP TO START</div>
</div>

<div id="game-over-screen">
  <h1 id="go-title">YOU MADE IT!</h1>
  <div class="stats" id="go-stats"></div>
  <div class="tap-msg" id="go-tap">TAP TO CONTINUE</div>
</div>

<canvas id="game"></canvas>

<script>
// ===== CANVAS =====
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// ===== LEVEL DEFINITIONS =====
const LEVELS = [
  {
    name: 'LEVEL 1',
    subtitle: 'Costa Rica → Airport',
    skyTop: '#0066cc', skyBot: '#88ccff',
    groundColor: '#2d8a2d', groundColor2: '#248024',
    roadColor: '#555555', roadLine: '#cccccc',
    bgMountColor: '#1a6b1a', bgMountColor2: '#117711',
    treeColor: '#0e6b0e', trunkColor: '#5a3a1a',
    buildingColors: [],
    hasTrees: true, hasPalms: true, hasBuildings: false, hasPlanes: false, hasTaxis: false,
    obstacleTypes: ['rock', 'pothole', 'chicken', 'fruit_stand'],
    cloudColor: '#ffffff',
    sunColor: '#ffdd44',
    length: 6000,
    speed: 140,
    music: 'tropical',
  },
  {
    name: 'LEVEL 2',
    subtitle: 'Airport → Plane Gate',
    skyTop: '#334466', skyBot: '#667799',
    groundColor: '#888888', groundColor2: '#7a7a7a',
    roadColor: '#666666', roadLine: '#ffcc00',
    bgMountColor: '#556677', bgMountColor2: '#445566',
    treeColor: '#336633', trunkColor: '#554433',
    buildingColors: ['#778899', '#667788', '#8899aa'],
    hasTrees: false, hasPalms: false, hasBuildings: true, hasPlanes: true, hasTaxis: true,
    obstacleTypes: ['luggage', 'cart', 'cone', 'sign'],
    cloudColor: '#ccccdd',
    sunColor: '#ccbbaa',
    length: 5500,
    speed: 155,
    music: 'airport',
  },
  {
    name: 'LEVEL 3',
    subtitle: 'NYC Airport → Brooklyn Home',
    skyTop: '#1a1a3a', skyBot: '#3a2a4a',
    groundColor: '#444444', groundColor2: '#3a3a3a',
    roadColor: '#555555', roadLine: '#ffffff',
    bgMountColor: '#2a2a3a', bgMountColor2: '#222233',
    treeColor: '#2a4a2a', trunkColor: '#3a2a1a',
    buildingColors: ['#334455', '#2a3a4a', '#3a4a5a', '#445566', '#223344'],
    hasTrees: true, hasPalms: false, hasBuildings: true, hasPlanes: false, hasTaxis: true,
    obstacleTypes: ['pothole', 'cone', 'taxi', 'hydrant'],
    cloudColor: '#555566',
    sunColor: '#ffaa66',
    length: 6500,
    speed: 170,
    music: 'city',
  }
];

// ===== GAME STATE =====
let gameState = 'start'; // start, levelIntro, playing, levelComplete, gameComplete, crashed
let currentLevel = 0;
let level = LEVELS[0];
let distance = 0;
let car = {};
let obstacles = [];
let decorations = [];
let particles = [];
let screenShake = 0;
let levelTimer = 0;
let totalTime = 0;
let lives = Infinity;
let boostFuel = 100;
let boosting = false;
let invincibleTimer = 0;
let score = 0;

// ===== INPUT =====
let jumpPressed = false;
let boostHeld = false;
let jumpJustPressed = false;

document.addEventListener('keydown', e => {
  if (e.code === 'Space' || e.code === 'ArrowUp' || e.key === 'w') {
    if (!jumpPressed) jumpJustPressed = true;
    jumpPressed = true;
  }
  if (e.code === 'ShiftLeft' || e.code === 'ShiftRight' || e.key === 'b') boostHeld = true;
  e.preventDefault();
});
document.addEventListener('keyup', e => {
  if (e.code === 'Space' || e.code === 'ArrowUp' || e.key === 'w') jumpPressed = false;
  if (e.code === 'ShiftLeft' || e.code === 'ShiftRight' || e.key === 'b') boostHeld = false;
});

let touchCount = 0;
canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  touchCount = e.touches.length;
  if (touchCount >= 2) {
    boostHeld = true;
  }
  if (!jumpPressed) jumpJustPressed = true;
  jumpPressed = true;
}, { passive: false });
canvas.addEventListener('touchend', e => {
  e.preventDefault();
  touchCount = e.touches.length;
  if (touchCount < 2) boostHeld = false;
  if (touchCount === 0) {
    jumpPressed = false;
    boostHeld = false;
  }
}, { passive: false });
canvas.addEventListener('touchcancel', e => {
  jumpPressed = false;
  boostHeld = false;
  touchCount = 0;
}, { passive: false });

// Mouse for desktop
canvas.addEventListener('mousedown', e => {
  if (e.button === 0) {
    if (!jumpPressed) jumpJustPressed = true;
    jumpPressed = true;
  }
  if (e.button === 2) boostHeld = true;
});
canvas.addEventListener('mouseup', e => {
  if (e.button === 0) jumpPressed = false;
  if (e.button === 2) boostHeld = false;
});
canvas.addEventListener('contextmenu', e => e.preventDefault());

// ===== INIT LEVEL =====
function initLevel(lvlIndex) {
  currentLevel = lvlIndex;
  level = LEVELS[lvlIndex];
  distance = 0;
  levelTimer = 0;
  boostFuel = 100;
  boosting = false;
  invincibleTimer = 0;
  obstacles = [];
  decorations = [];
  particles = [];
  screenShake = 0;

  car = {
    x: 150,
    y: 0,
    vy: 0,
    grounded: true,
    jumping: false,
    width: 60,
    height: 30,
    wheelRadius: 8,
    rotation: 0,
  };

  // Pre-generate obstacles
  let nextObs = 600 + Math.random() * 400;
  while (nextObs < level.length - 200) {
    const type = level.obstacleTypes[Math.floor(Math.random() * level.obstacleTypes.length)];
    obstacles.push(createObstacle(type, nextObs));
    // Extra easy spacing for young players
    nextObs += 500 + Math.random() * 500;
  }

  // Pre-generate decorations
  let nextDec = 100;
  while (nextDec < level.length) {
    decorations.push(createDecoration(nextDec));
    nextDec += 60 + Math.random() * 120;
  }
}

function createObstacle(type, worldX) {
  const obs = { type, worldX, hit: false };
  switch (type) {
    case 'rock':
      obs.w = 50; obs.h = 40; obs.color = '#887766'; obs.color2 = '#665544'; break;
    case 'pothole':
      obs.w = 70; obs.h = 12; obs.color = '#222222'; obs.color2 = '#111111'; obs.ground = true; break;
    case 'chicken':
      obs.w = 30; obs.h = 32; obs.color = '#ffffff'; obs.color2 = '#ff4444';
      obs.anim = Math.random() * Math.PI * 2; break;
    case 'fruit_stand':
      obs.w = 65; obs.h = 55; obs.color = '#884422'; obs.color2 = '#ff6633'; break;
    case 'luggage':
      obs.w = 45; obs.h = 50; obs.color = '#3355aa'; obs.color2 = '#224488'; break;
    case 'cart':
      obs.w = 75; obs.h = 42; obs.color = '#888888'; obs.color2 = '#666666'; break;
    case 'cone':
      obs.w = 28; obs.h = 40; obs.color = '#ff6600'; obs.color2 = '#ffffff'; break;
    case 'sign':
      obs.w = 42; obs.h = 60; obs.color = '#ffcc00'; obs.color2 = '#333333'; break;
    case 'taxi':
      obs.w = 80; obs.h = 42; obs.color = '#ffcc00'; obs.color2 = '#222222'; break;
    case 'hydrant':
      obs.w = 28; obs.h = 42; obs.color = '#cc2200'; obs.color2 = '#991100'; break;
    default:
      obs.w = 30; obs.h = 30; obs.color = '#888'; obs.color2 = '#666';
  }
  return obs;
}

function createDecoration(worldX) {
  const d = { worldX, layer: Math.random() < 0.6 ? 'back' : 'front' };
  const r = Math.random();

  if (level.hasPalms && r < 0.4) {
    d.type = 'palm';
    d.h = 60 + Math.random() * 40;
    d.lean = (Math.random() - 0.5) * 0.3;
  } else if (level.hasTrees && r < 0.6) {
    d.type = 'tree';
    d.h = 40 + Math.random() * 30;
  } else if (level.hasBuildings && r < 0.7) {
    d.type = 'building';
    d.h = 80 + Math.random() * 120;
    d.w = 40 + Math.random() * 60;
    d.color = level.buildingColors[Math.floor(Math.random() * level.buildingColors.length)];
    d.layer = 'back';
  } else if (level.hasPlanes && r < 0.72) {
    d.type = 'plane';
    d.h = 30;
    d.skyY = 0.15 + Math.random() * 0.2;
    d.layer = 'sky';
  } else if (level.hasTaxis && r < 0.78) {
    d.type = 'bg_car';
    d.color = ['#ffcc00', '#cc3333', '#3366cc', '#33aa33'][Math.floor(Math.random() * 4)];
    d.layer = 'back';
  } else {
    d.type = 'bush';
    d.h = 12 + Math.random() * 15;
  }
  return d;
}

// ===== PARTICLES =====
function spawnParticles(x, y, color1, color2, count, spread, speed) {
  for (let i = 0; i < count; i++) {
    particles.push({
      x, y,
      vx: (Math.random() - 0.5) * spread + (Math.random() * speed * 0.3),
      vy: -(Math.random() * speed) - speed * 0.5,
      life: 0.3 + Math.random() * 0.5,
      maxLife: 0.3 + Math.random() * 0.5,
      size: 2 + Math.random() * 4,
      color: Math.random() < 0.5 ? color1 : color2,
      gravity: 400,
    });
  }
}

function spawnFireSparks(x, y, scale) {
  for (let i = 0; i < 3; i++) {
    particles.push({
      x: x + (Math.random() - 0.5) * 6,
      y: y + (Math.random() - 0.5) * 4,
      vx: (80 + Math.random() * 120) * scale,
      vy: -(20 + Math.random() * 60) * scale,
      life: 0.2 + Math.random() * 0.3,
      maxLife: 0.2 + Math.random() * 0.3,
      size: (2 + Math.random() * 3) * scale,
      color: ['#ff4400', '#ff8800', '#ffcc00', '#ffff44'][Math.floor(Math.random() * 4)],
      gravity: 200,
      fire: true,
    });
  }
  // Spark dots
  for (let i = 0; i < 2; i++) {
    particles.push({
      x: x + (Math.random() - 0.5) * 10,
      y: y + (Math.random() - 0.5) * 6,
      vx: (100 + Math.random() * 150) * scale,
      vy: -(30 + Math.random() * 80) * scale,
      life: 0.15 + Math.random() * 0.2,
      maxLife: 0.15 + Math.random() * 0.2,
      size: 1 + Math.random() * 2,
      color: '#ffffff',
      gravity: 300,
      fire: true,
    });
  }
}

function spawnCrashParticles(x, y) {
  for (let i = 0; i < 20; i++) {
    particles.push({
      x, y,
      vx: (Math.random() - 0.5) * 300,
      vy: -(50 + Math.random() * 250),
      life: 0.5 + Math.random() * 0.8,
      maxLife: 0.5 + Math.random() * 0.8,
      size: 3 + Math.random() * 6,
      color: ['#ff4400', '#ff8800', '#ffcc00', '#888888', '#aaaaaa'][Math.floor(Math.random() * 5)],
      gravity: 500,
    });
  }
}

// ===== UPDATE =====
function update(dt) {
  if (gameState !== 'playing') return;

  levelTimer += dt;
  const baseSpeed = level.speed;
  const boostMultiplier = boosting ? 1.6 : 1.0;
  const currentSpeed = baseSpeed * boostMultiplier;

  // Boost logic
  if (boostHeld && boostFuel > 0) {
    boosting = true;
    boostFuel -= dt * 30;
    if (boostFuel < 0) boostFuel = 0;
  } else {
    boosting = false;
    boostFuel = Math.min(100, boostFuel + dt * 12);
  }

  // Fire sparks only when boosting
  if (boosting) {
    const groundY = canvas.height * 0.72;
    const carBottom = groundY - car.y;
    spawnFireSparks(car.x + 25, carBottom, 1);
    spawnFireSparks(car.x + 20, carBottom + 2, 0.8);
  }

  // Move world
  distance += currentSpeed * dt;

  // Jump
  if (jumpJustPressed && car.grounded) {
    car.vy = -400;
    car.grounded = false;
    car.jumping = true;
  }
  jumpJustPressed = false;

  // Gravity
  if (!car.grounded) {
    car.vy += 1000 * dt;
    car.y -= car.vy * dt;
    if (car.y <= 0) {
      car.y = 0;
      car.vy = 0;
      car.grounded = true;
      car.jumping = false;
      // Landing dust
      const groundY = canvas.height * 0.72;
      spawnParticles(car.x, groundY, '#aa9977', '#887766', 6, 80, 30);
    }
  }

  // Car rotation during jump
  if (!car.grounded) {
    car.rotation = Math.min(0.15, Math.max(-0.2, car.vy * 0.0003));
  } else {
    car.rotation *= 0.85;
  }

  // Invincibility countdown
  if (invincibleTimer > 0) invincibleTimer -= dt;

  // Check obstacle collisions
  const groundY = canvas.height * 0.72;
  const carScreenBottom = groundY - car.y;
  const carScreenTop = carScreenBottom - car.height;
  const carLeft = car.x - car.width / 2;
  const carRight = car.x + car.width / 2;

  for (const obs of obstacles) {
    if (obs.hit) continue;
    const obsScreenX = obs.worldX - distance + canvas.width * 0.3;
    if (obsScreenX < -100 || obsScreenX > canvas.width + 100) continue;

    const obsLeft = obsScreenX - obs.w / 2;
    const obsRight = obsScreenX + obs.w / 2;
    const obsTop = obs.ground ? groundY - 4 : groundY - obs.h;
    const obsBottom = groundY;

    // Collision check
    if (carRight > obsLeft + 5 && carLeft < obsRight - 5 &&
        carScreenBottom > obsTop + 5 && carScreenTop < obsBottom) {
      if (invincibleTimer <= 0) {
        obs.hit = true;
        screenShake = 0.3;
        spawnCrashParticles(obsScreenX, groundY - obs.h / 2);
        lives--;
        invincibleTimer = 2.0;
        score -= 50;
        if (score < 0) score = 0;
        if (lives <= 0) {
          gameState = 'crashed';
          showGameOver(false);
          return;
        }
      }
    }
  }

  // Score
  score += Math.floor(currentSpeed * dt * 0.1);

  // Screen shake decay
  if (screenShake > 0) screenShake -= dt;

  // Update particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vy += (p.gravity || 0) * dt;
    p.life -= dt;
    if (p.fire) p.size *= 0.95;
    if (p.life <= 0) particles.splice(i, 1);
  }

  // Cap particles
  if (particles.length > 200) particles.splice(0, particles.length - 200);

  // Dust from driving on ground
  if (car.grounded && currentSpeed > 100) {
    if (Math.random() < 0.3) {
      particles.push({
        x: car.x + 30 + Math.random() * 5,
        y: groundY - 2,
        vx: (20 + Math.random() * 30),
        vy: -(5 + Math.random() * 15),
        life: 0.3 + Math.random() * 0.2,
        maxLife: 0.5,
        size: 2 + Math.random() * 3,
        color: '#aa9977',
        gravity: 30,
      });
    }
  }

  // Level complete?
  if (distance >= level.length) {
    totalTime += levelTimer;
    if (currentLevel < LEVELS.length - 1) {
      gameState = 'levelComplete';
      showGameOver(true);
    } else {
      gameState = 'gameComplete';
      showGameOver(true);
    }
  }
}

// ===== RENDER =====
function render() {
  const w = canvas.width;
  const h = canvas.height;
  const groundY = h * 0.72;

  // Screen shake offset
  let shakeX = 0, shakeY = 0;
  if (screenShake > 0) {
    shakeX = (Math.random() - 0.5) * 12;
    shakeY = (Math.random() - 0.5) * 12;
  }
  ctx.save();
  ctx.translate(shakeX, shakeY);

  // === SKY ===
  const skyGrad = ctx.createLinearGradient(0, 0, 0, groundY);
  skyGrad.addColorStop(0, level.skyTop);
  skyGrad.addColorStop(1, level.skyBot);
  ctx.fillStyle = skyGrad;
  ctx.fillRect(0, 0, w, groundY);

  // Sun/Moon
  const sunX = w * 0.82;
  const sunY = h * 0.12;
  ctx.fillStyle = level.sunColor;
  ctx.globalAlpha = 0.8;
  ctx.beginPath();
  ctx.arc(sunX, sunY, 30, 0, Math.PI * 2);
  ctx.fill();
  ctx.globalAlpha = 0.3;
  ctx.beginPath();
  ctx.arc(sunX, sunY, 45, 0, Math.PI * 2);
  ctx.fill();
  ctx.globalAlpha = 1;

  // Clouds
  drawClouds(w, h, groundY);

  // === BACKGROUND MOUNTAINS/CITYSCAPE ===
  drawBackground(w, h, groundY);

  // === DECORATIONS (back layer) ===
  for (const d of decorations) {
    if (d.layer === 'sky') {
      drawSkyDecoration(d, w, h);
      continue;
    }
    if (d.layer !== 'back') continue;
    const sx = d.worldX * 0.6 - distance * 0.6 + w * 0.3;
    if (sx < -150 || sx > w + 150) continue;
    drawDecoration(d, sx, groundY);
  }

  // === GROUND ===
  // Main ground
  ctx.fillStyle = level.groundColor;
  ctx.fillRect(0, groundY, w, h - groundY);

  // Road surface
  const roadTop = groundY;
  const roadH = h - groundY;
  ctx.fillStyle = level.roadColor;
  ctx.fillRect(0, roadTop, w, roadH);

  // Road lines
  const lineY = groundY + 20;
  ctx.fillStyle = level.roadLine;
  const dashLen = 40;
  const gapLen = 30;
  const lineOffset = (distance * 1.0) % (dashLen + gapLen);
  ctx.globalAlpha = 0.6;
  for (let x = -lineOffset; x < w + dashLen; x += dashLen + gapLen) {
    ctx.fillRect(x, lineY, dashLen, 3);
  }
  ctx.globalAlpha = 1;

  // Road edge lines
  ctx.fillStyle = level.roadLine;
  ctx.globalAlpha = 0.4;
  ctx.fillRect(0, groundY, w, 2);
  ctx.fillRect(0, h - 2, w, 2);
  ctx.globalAlpha = 1;

  // === OBSTACLES ===
  for (const obs of obstacles) {
    if (obs.hit) continue;
    const sx = obs.worldX - distance + w * 0.3;
    if (sx < -80 || sx > w + 80) continue;
    drawObstacle(obs, sx, groundY);
  }

  // === CAR ===
  drawCar(car.x, groundY - car.y, boosting);

  // === DECORATIONS (front layer) ===
  for (const d of decorations) {
    if (d.layer !== 'front') continue;
    const sx = d.worldX * 1.2 - distance * 1.2 + w * 0.3;
    if (sx < -100 || sx > w + 100) continue;
    drawDecorationFront(d, sx, h);
  }

  // === PARTICLES ===
  for (const p of particles) {
    const t = p.life / p.maxLife;
    ctx.globalAlpha = Math.min(1, t * 2);
    ctx.fillStyle = p.color;
    const s = p.size * (p.fire ? t : 1);
    ctx.fillRect(Math.floor(p.x - s/2), Math.floor(p.y - s/2), Math.ceil(s), Math.ceil(s));
  }
  ctx.globalAlpha = 1;

  ctx.restore();

  // === HUD (not affected by shake) ===
  drawHUD(w, h);

  // Invincibility flash
  if (invincibleTimer > 0) {
    if (Math.floor(invincibleTimer * 8) % 2 === 0) {
      ctx.globalAlpha = 0.1;
      ctx.fillStyle = '#ff0000';
      ctx.fillRect(0, 0, w, h);
      ctx.globalAlpha = 1;
    }
  }
}

// ===== DRAW CLOUDS =====
function drawClouds(w, h, groundY) {
  ctx.fillStyle = level.cloudColor;
  ctx.globalAlpha = 0.3;
  const cloudOffset = distance * 0.05;
  for (let i = 0; i < 5; i++) {
    const cx = ((i * 320 + 100 - cloudOffset) % (w + 200)) - 100;
    const cy = 40 + i * 25 + Math.sin(i * 2.5) * 20;
    drawCloud(cx, cy, 30 + i * 8);
  }
  ctx.globalAlpha = 1;
}

function drawCloud(cx, cy, size) {
  ctx.beginPath();
  ctx.arc(cx, cy, size * 0.6, 0, Math.PI * 2);
  ctx.arc(cx - size * 0.5, cy + size * 0.1, size * 0.4, 0, Math.PI * 2);
  ctx.arc(cx + size * 0.5, cy + size * 0.1, size * 0.45, 0, Math.PI * 2);
  ctx.arc(cx + size * 0.2, cy - size * 0.2, size * 0.35, 0, Math.PI * 2);
  ctx.fill();
}

// ===== DRAW BACKGROUND =====
function drawBackground(w, h, groundY) {
  // Far mountains/buildings
  ctx.fillStyle = level.bgMountColor;
  ctx.beginPath();
  ctx.moveTo(0, groundY);
  const bgOffset = distance * 0.1;
  if (level.hasBuildings) {
    // Cityscape
    let bx = -bgOffset % 80;
    while (bx < w + 80) {
      const bh = 40 + Math.abs(Math.sin(bx * 0.01 + 1.5)) * 100;
      const bw = 30 + Math.abs(Math.sin(bx * 0.02 + 3)) * 40;
      ctx.fillRect(bx, groundY - bh, bw, bh);
      // Windows
      ctx.fillStyle = '#ffcc66';
      ctx.globalAlpha = 0.3;
      for (let wy = groundY - bh + 8; wy < groundY - 8; wy += 12) {
        for (let wx = bx + 5; wx < bx + bw - 5; wx += 10) {
          if (Math.random() < 0.6) {
            ctx.fillRect(wx, wy, 5, 6);
          }
        }
      }
      ctx.globalAlpha = 1;
      ctx.fillStyle = level.bgMountColor;
      bx += bw + 10 + Math.abs(Math.sin(bx * 0.03)) * 15;
    }
  } else {
    // Mountains
    for (let x = 0; x <= w; x += 3) {
      const mh = Math.sin((x + bgOffset) * 0.004) * 50 +
                 Math.sin((x + bgOffset) * 0.009) * 30 + 70;
      ctx.lineTo(x, groundY - mh);
    }
    ctx.lineTo(w, groundY);
    ctx.fill();
  }

  // Near layer
  ctx.fillStyle = level.bgMountColor2;
  ctx.beginPath();
  ctx.moveTo(0, groundY);
  const bgOffset2 = distance * 0.2;
  for (let x = 0; x <= w; x += 3) {
    const mh = Math.sin((x + bgOffset2) * 0.006) * 30 +
               Math.sin((x + bgOffset2) * 0.013) * 20 + 35;
    ctx.lineTo(x, groundY - mh);
  }
  ctx.lineTo(w, groundY);
  ctx.fill();
}

// ===== DRAW DECORATIONS =====
function drawSkyDecoration(d, w, h) {
  if (d.type === 'plane') {
    const sx = d.worldX * 0.3 - distance * 0.15 + w * 0.5;
    if (sx < -100 || sx > w + 100) return;
    ctx.fillStyle = '#cccccc';
    // Fuselage
    ctx.fillRect(sx - 20, h * d.skyY, 40, 8);
    // Wings
    ctx.fillRect(sx - 5, h * d.skyY - 10, 10, 28);
    // Tail
    ctx.fillRect(sx - 22, h * d.skyY - 6, 8, 6);
  }
}

function drawDecoration(d, sx, groundY) {
  if (d.type === 'palm') {
    // Trunk
    ctx.fillStyle = '#8B6914';
    ctx.save();
    ctx.translate(sx, groundY);
    ctx.rotate(d.lean);
    ctx.fillRect(-3, -d.h, 6, d.h);
    // Fronds
    ctx.fillStyle = '#228B22';
    for (let i = 0; i < 5; i++) {
      const angle = (i / 5) * Math.PI * 2 + performance.now() * 0.0005;
      ctx.save();
      ctx.translate(0, -d.h);
      ctx.rotate(Math.sin(angle) * 0.4);
      ctx.fillRect(-2, 0, 4, -25 - Math.random() * 5);
      ctx.beginPath();
      ctx.ellipse(0, -28, 12, 5, Math.sin(angle) * 0.3, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
    ctx.restore();
  } else if (d.type === 'tree') {
    ctx.fillStyle = level.trunkColor;
    ctx.fillRect(sx - 3, groundY - d.h, 6, d.h);
    ctx.fillStyle = level.treeColor;
    ctx.beginPath();
    ctx.arc(sx, groundY - d.h - 10, 16 + d.h * 0.15, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#1a5a1a';
    ctx.beginPath();
    ctx.arc(sx - 5, groundY - d.h - 5, 10 + d.h * 0.1, 0, Math.PI * 2);
    ctx.fill();
  } else if (d.type === 'building') {
    ctx.fillStyle = d.color;
    ctx.fillRect(sx - d.w / 2, groundY - d.h, d.w, d.h);
    // Windows
    ctx.fillStyle = '#ffcc55';
    ctx.globalAlpha = 0.5;
    for (let wy = groundY - d.h + 10; wy < groundY - 5; wy += 14) {
      for (let wx = sx - d.w / 2 + 6; wx < sx + d.w / 2 - 6; wx += 12) {
        if (Math.sin(wx * 3.7 + wy * 1.3) > -0.3) {
          ctx.fillRect(wx, wy, 7, 8);
        }
      }
    }
    ctx.globalAlpha = 1;
  } else if (d.type === 'bg_car') {
    ctx.fillStyle = d.color;
    ctx.fillRect(sx - 15, groundY - 14, 30, 10);
    ctx.fillStyle = '#88bbcc';
    ctx.fillRect(sx - 6, groundY - 20, 14, 7);
    ctx.fillStyle = '#222';
    ctx.fillRect(sx - 12, groundY - 5, 7, 7);
    ctx.fillRect(sx + 5, groundY - 5, 7, 7);
  } else if (d.type === 'bush') {
    ctx.fillStyle = level.treeColor;
    ctx.beginPath();
    ctx.arc(sx, groundY - d.h * 0.4, d.h * 0.6, 0, Math.PI * 2);
    ctx.fill();
  }
}

function drawDecorationFront(d, sx, h) {
  // Front layer items are below road - just show tops of bushes peeking up
  if (d.type === 'bush') {
    ctx.fillStyle = level.treeColor;
    ctx.globalAlpha = 0.4;
    ctx.beginPath();
    ctx.arc(sx, h - 5, d.h * 0.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }
}

// ===== DRAW OBSTACLES =====
function drawObstacle(obs, sx, groundY) {
  const t = performance.now() / 1000;
  // Pulsing red danger glow beneath every obstacle
  const glowPulse = 0.15 + Math.sin(t * 4) * 0.08;
  ctx.globalAlpha = glowPulse;
  ctx.fillStyle = '#ff0000';
  ctx.beginPath();
  ctx.ellipse(sx, groundY - 2, obs.w * 0.8 + 10, 12, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.globalAlpha = 1;
  switch (obs.type) {
    case 'rock':
      ctx.fillStyle = obs.color;
      ctx.beginPath();
      ctx.moveTo(sx - obs.w/2, groundY);
      ctx.lineTo(sx - obs.w/3, groundY - obs.h);
      ctx.lineTo(sx + obs.w/4, groundY - obs.h * 0.9);
      ctx.lineTo(sx + obs.w/2, groundY);
      ctx.fill();
      ctx.fillStyle = obs.color2;
      ctx.beginPath();
      ctx.moveTo(sx - obs.w/3, groundY - obs.h);
      ctx.lineTo(sx + obs.w/4, groundY - obs.h * 0.9);
      ctx.lineTo(sx, groundY - obs.h * 0.5);
      ctx.fill();
      // Warning icon
      drawWarningSign(sx, groundY - obs.h - 18);
      break;

    case 'pothole':
      ctx.fillStyle = obs.color;
      ctx.beginPath();
      ctx.ellipse(sx, groundY - 2, obs.w/2, obs.h/2, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#333';
      ctx.beginPath();
      ctx.ellipse(sx, groundY - 2, obs.w/2 - 3, obs.h/2 - 1, 0, 0, Math.PI * 2);
      ctx.fill();
      drawWarningSign(sx, groundY - 25);
      break;

    case 'chicken':
      const bx = Math.sin(t * 6 + obs.anim) * 3;
      // Body
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.ellipse(sx + bx, groundY - 12, 8, 10, 0, 0, Math.PI * 2);
      ctx.fill();
      // Head
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(sx + bx + 6, groundY - 20, 5, 0, Math.PI * 2);
      ctx.fill();
      // Beak
      ctx.fillStyle = '#ff8800';
      ctx.fillRect(sx + bx + 10, groundY - 20, 4, 3);
      // Comb
      ctx.fillStyle = '#ff2200';
      ctx.fillRect(sx + bx + 5, groundY - 26, 4, 5);
      // Legs
      ctx.fillStyle = '#ff8800';
      ctx.fillRect(sx + bx - 2, groundY - 4, 2, 4);
      ctx.fillRect(sx + bx + 3, groundY - 4, 2, 4);
      // Eye
      ctx.fillStyle = '#000';
      ctx.fillRect(sx + bx + 8, groundY - 21, 2, 2);
      drawWarningSign(sx, groundY - 32);
      break;

    case 'fruit_stand':
      // Table
      ctx.fillStyle = obs.color;
      ctx.fillRect(sx - obs.w/2, groundY - 25, obs.w, 5);
      // Legs
      ctx.fillRect(sx - obs.w/2 + 2, groundY - 20, 3, 20);
      ctx.fillRect(sx + obs.w/2 - 5, groundY - 20, 3, 20);
      // Fruits
      const fruitColors = ['#ff3300', '#ffaa00', '#ff6600', '#ffff00', '#00cc00'];
      for (let i = 0; i < 6; i++) {
        ctx.fillStyle = fruitColors[i % fruitColors.length];
        ctx.beginPath();
        ctx.arc(sx - obs.w/2 + 8 + i * 8, groundY - 30, 4, 0, Math.PI * 2);
        ctx.fill();
      }
      // Canopy
      ctx.fillStyle = '#cc4400';
      ctx.fillRect(sx - obs.w/2 - 3, groundY - obs.h, obs.w + 6, 8);
      drawWarningSign(sx, groundY - obs.h - 15);
      break;

    case 'luggage':
      ctx.fillStyle = obs.color;
      ctx.fillRect(sx - obs.w/2, groundY - obs.h, obs.w, obs.h);
      ctx.fillStyle = obs.color2;
      ctx.fillRect(sx - obs.w/2 + 3, groundY - obs.h + 3, obs.w - 6, 4);
      ctx.fillRect(sx - obs.w/2 + 3, groundY - obs.h/2, obs.w - 6, 4);
      // Handle
      ctx.fillStyle = '#333';
      ctx.fillRect(sx - 3, groundY - obs.h - 8, 6, 10);
      drawWarningSign(sx, groundY - obs.h - 20);
      break;

    case 'cart':
      ctx.fillStyle = obs.color;
      ctx.fillRect(sx - obs.w/2, groundY - obs.h, obs.w, obs.h - 8);
      // Wheels
      ctx.fillStyle = '#333';
      ctx.beginPath();
      ctx.arc(sx - obs.w/3, groundY - 4, 6, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(sx + obs.w/3, groundY - 4, 6, 0, Math.PI * 2);
      ctx.fill();
      // Handle
      ctx.fillStyle = '#666';
      ctx.fillRect(sx + obs.w/2, groundY - obs.h + 5, 15, 3);
      drawWarningSign(sx, groundY - obs.h - 15);
      break;

    case 'cone':
      ctx.fillStyle = obs.color;
      ctx.beginPath();
      ctx.moveTo(sx - obs.w/2, groundY);
      ctx.lineTo(sx - 3, groundY - obs.h);
      ctx.lineTo(sx + 3, groundY - obs.h);
      ctx.lineTo(sx + obs.w/2, groundY);
      ctx.fill();
      // White stripes
      ctx.fillStyle = obs.color2;
      ctx.fillRect(sx - 6, groundY - obs.h * 0.6, 12, 4);
      ctx.fillRect(sx - 4, groundY - obs.h * 0.8, 8, 3);
      break;

    case 'sign':
      // Post
      ctx.fillStyle = '#666';
      ctx.fillRect(sx - 2, groundY - obs.h, 4, obs.h);
      // Sign board
      ctx.fillStyle = obs.color;
      ctx.fillRect(sx - 15, groundY - obs.h, 30, 20);
      ctx.fillStyle = '#000';
      ctx.font = 'bold 10px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('!', sx, groundY - obs.h + 15);
      break;

    case 'taxi':
      // Body
      ctx.fillStyle = obs.color;
      ctx.fillRect(sx - obs.w/2, groundY - 18, obs.w, 14);
      // Roof
      ctx.fillStyle = '#ddbb00';
      ctx.fillRect(sx - 14, groundY - 26, 28, 9);
      // Windows
      ctx.fillStyle = '#88bbcc';
      ctx.fillRect(sx - 11, groundY - 25, 10, 6);
      ctx.fillRect(sx + 2, groundY - 25, 10, 6);
      // Wheels
      ctx.fillStyle = '#222';
      ctx.beginPath();
      ctx.arc(sx - obs.w/3, groundY - 3, 5, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(sx + obs.w/3, groundY - 3, 5, 0, Math.PI * 2);
      ctx.fill();
      // Taxi sign
      ctx.fillStyle = '#fff';
      ctx.fillRect(sx - 6, groundY - 30, 12, 5);
      ctx.fillStyle = '#000';
      ctx.font = '5px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('TAXI', sx, groundY - 26);
      drawWarningSign(sx, groundY - 38);
      break;

    case 'hydrant':
      ctx.fillStyle = obs.color;
      ctx.fillRect(sx - obs.w/2, groundY - obs.h, obs.w, obs.h);
      ctx.fillStyle = obs.color2;
      ctx.fillRect(sx - obs.w/2 - 3, groundY - obs.h + 5, obs.w + 6, 5);
      ctx.fillRect(sx - obs.w/2 - 3, groundY - obs.h * 0.4, obs.w + 6, 5);
      // Top
      ctx.fillStyle = obs.color;
      ctx.beginPath();
      ctx.arc(sx, groundY - obs.h, obs.w/2, Math.PI, 0);
      ctx.fill();
      break;
  }
}

function drawWarningSign(x, y) {
  const t = performance.now() / 250;
  const alpha = 0.6 + Math.sin(t) * 0.4;
  // Red glow behind the sign
  ctx.globalAlpha = alpha * 0.4;
  ctx.fillStyle = '#ff0000';
  ctx.beginPath();
  ctx.arc(x, y - 4, 18, 0, Math.PI * 2);
  ctx.fill();
  // Yellow triangle - bigger
  ctx.globalAlpha = alpha;
  ctx.fillStyle = '#ffcc00';
  ctx.beginPath();
  ctx.moveTo(x, y - 16);
  ctx.lineTo(x - 13, y + 6);
  ctx.lineTo(x + 13, y + 6);
  ctx.fill();
  // Red border
  ctx.strokeStyle = '#ff3300';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(x, y - 16);
  ctx.lineTo(x - 13, y + 6);
  ctx.lineTo(x + 13, y + 6);
  ctx.closePath();
  ctx.stroke();
  // Exclamation mark
  ctx.fillStyle = '#000';
  ctx.font = 'bold 14px monospace';
  ctx.textAlign = 'center';
  ctx.fillText('!', x, y + 3);
  ctx.globalAlpha = 1;
}

// ===== DRAW CAR =====
function drawCar(cx, groundY, isBoosting) {
  const carY = groundY;
  const y = carY - car.y;

  ctx.save();
  ctx.translate(cx, y);
  ctx.rotate(car.rotation);
  ctx.scale(-1, 1); // Flip car to face correct direction

  // Invincibility blink
  if (invincibleTimer > 0 && Math.floor(invincibleTimer * 10) % 2 === 0) {
    ctx.globalAlpha = 0.4;
  }

  // Shadow
  ctx.globalAlpha = Math.min(ctx.globalAlpha || 1, 0.2);
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.ellipse(0, car.y + 3, 32, 5, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.globalAlpha = (invincibleTimer > 0 && Math.floor(invincibleTimer * 10) % 2 === 0) ? 0.4 : 1;

  // === Main body ===
  ctx.fillStyle = '#ff4400';
  // Lower body
  ctx.fillRect(-28, -12, 56, 12);
  // Upper body / cabin
  ctx.fillStyle = '#ee3300';
  ctx.fillRect(-10, -22, 26, 11);

  // Hood (front slope)
  ctx.fillStyle = '#ff5500';
  ctx.beginPath();
  ctx.moveTo(16, -22);
  ctx.lineTo(28, -12);
  ctx.lineTo(28, -8);
  ctx.lineTo(16, -11);
  ctx.fill();

  // Trunk (back slope)
  ctx.fillStyle = '#dd3300';
  ctx.beginPath();
  ctx.moveTo(-10, -22);
  ctx.lineTo(-20, -12);
  ctx.lineTo(-10, -11);
  ctx.fill();

  // Windshield
  ctx.fillStyle = '#66aadd';
  ctx.beginPath();
  ctx.moveTo(14, -21);
  ctx.lineTo(24, -13);
  ctx.lineTo(24, -12);
  ctx.lineTo(14, -12);
  ctx.fill();

  // Rear window
  ctx.fillStyle = '#5599cc';
  ctx.beginPath();
  ctx.moveTo(-8, -21);
  ctx.lineTo(-16, -13);
  ctx.lineTo(-8, -12);
  ctx.fill();

  // Hot Wheels flame decal
  ctx.fillStyle = '#ffaa00';
  ctx.fillRect(-26, -10, 10, 3);
  ctx.fillStyle = '#ffcc00';
  ctx.fillRect(-22, -7, 6, 2);
  ctx.fillRect(18, -10, 8, 3);
  ctx.fillStyle = '#ffaa00';
  ctx.fillRect(20, -7, 5, 2);

  // Racing stripe
  ctx.fillStyle = '#ffcc00';
  ctx.fillRect(-2, -12, 4, 12);
  ctx.globalAlpha = (invincibleTimer > 0 && Math.floor(invincibleTimer * 10) % 2 === 0) ? 0.2 : 0.5;
  ctx.fillRect(-2, -22, 4, 10);
  ctx.globalAlpha = (invincibleTimer > 0 && Math.floor(invincibleTimer * 10) % 2 === 0) ? 0.4 : 1;

  // Headlights
  ctx.fillStyle = '#ffffaa';
  ctx.fillRect(26, -10, 3, 4);
  if (isBoosting) {
    ctx.fillStyle = '#ffffff';
    ctx.globalAlpha = 0.6;
    ctx.fillRect(29, -12, 8, 8);
    ctx.globalAlpha = (invincibleTimer > 0 && Math.floor(invincibleTimer * 10) % 2 === 0) ? 0.4 : 1;
  }

  // Tail lights
  ctx.fillStyle = '#ff0000';
  ctx.fillRect(-30, -10, 3, 4);

  // Wheels
  const wheelSpin = distance * 0.3;
  // Front wheel
  drawWheel(20, 0, 8, wheelSpin, isBoosting);
  // Rear wheel
  drawWheel(-18, 0, 8, wheelSpin, isBoosting);

  // Boost glow
  if (isBoosting) {
    ctx.globalAlpha = 0.25 + Math.sin(performance.now() * 0.02) * 0.1;
    ctx.fillStyle = '#ff6600';
    ctx.beginPath();
    ctx.ellipse(0, -10, 40, 20, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // Exhaust flames
    const flameLen = 15 + Math.random() * 20;
    ctx.fillStyle = '#ff4400';
    ctx.beginPath();
    ctx.moveTo(-30, -10);
    ctx.lineTo(-30 - flameLen, -8 + Math.random() * 4);
    ctx.lineTo(-30, -6);
    ctx.fill();
    ctx.fillStyle = '#ffaa00';
    ctx.beginPath();
    ctx.moveTo(-30, -9);
    ctx.lineTo(-30 - flameLen * 0.6, -8 + Math.random() * 2);
    ctx.lineTo(-30, -7);
    ctx.fill();
    ctx.fillStyle = '#ffff44';
    ctx.beginPath();
    ctx.moveTo(-30, -9);
    ctx.lineTo(-30 - flameLen * 0.3, -8);
    ctx.lineTo(-30, -7);
    ctx.fill();
  }

  ctx.globalAlpha = 1;
  ctx.restore();
}

function drawWheel(wx, wy, r, spin, isBoosting) {
  // Tire
  ctx.fillStyle = '#222';
  ctx.beginPath();
  ctx.arc(wx, wy, r, 0, Math.PI * 2);
  ctx.fill();

  // Rim
  ctx.fillStyle = '#999';
  ctx.beginPath();
  ctx.arc(wx, wy, r * 0.55, 0, Math.PI * 2);
  ctx.fill();

  // Spokes
  ctx.fillStyle = '#bbb';
  for (let i = 0; i < 4; i++) {
    const a = spin + i * Math.PI / 2;
    ctx.fillRect(
      wx + Math.cos(a) * 1 - 1,
      wy + Math.sin(a) * 1 - 1,
      Math.cos(a) * r * 0.4 + 2,
      Math.sin(a) * r * 0.4 + 2
    );
  }

  // Center cap
  ctx.fillStyle = '#ddd';
  ctx.beginPath();
  ctx.arc(wx, wy, r * 0.2, 0, Math.PI * 2);
  ctx.fill();
}

// ===== DRAW HUD =====
function drawHUD(w, h) {
  const pad = 12;
  const fontSize = Math.max(14, Math.min(20, w * 0.035));

  ctx.font = `bold ${fontSize}px monospace`;
  ctx.textBaseline = 'top';

  // Level name - top center
  ctx.textAlign = 'center';
  ctx.fillStyle = '#ffcc00';
  ctx.shadowColor = '#ff9900';
  ctx.shadowBlur = 6;
  ctx.fillText(`${level.name}: ${level.subtitle}`, w / 2, pad);
  ctx.shadowBlur = 0;

  // Lives - top left
  ctx.textAlign = 'left';
  ctx.fillStyle = '#ff4444';
  ctx.fillText('\u2764 \u221E', pad, pad + fontSize + 8);

  // Score - top right
  ctx.textAlign = 'right';
  ctx.fillStyle = '#88ccff';
  ctx.fillText(`SCORE: ${score}`, w - pad, pad);

  // Timer
  const mins = Math.floor(levelTimer / 60);
  const secs = Math.floor(levelTimer % 60);
  ctx.fillText(
    `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`,
    w - pad, pad + fontSize + 8
  );

  // Progress bar - bottom
  const barW = w * 0.6;
  const barH = 10;
  const barX = (w - barW) / 2;
  const barY = h - 30;
  const progress = Math.min(1, distance / level.length);

  ctx.fillStyle = '#333';
  ctx.globalAlpha = 0.6;
  ctx.fillRect(barX, barY, barW, barH);
  ctx.globalAlpha = 1;

  const barGrad = ctx.createLinearGradient(barX, 0, barX + barW, 0);
  barGrad.addColorStop(0, '#ff4400');
  barGrad.addColorStop(1, '#ffcc00');
  ctx.fillStyle = barGrad;
  ctx.fillRect(barX, barY, barW * progress, barH);

  ctx.strokeStyle = '#666';
  ctx.lineWidth = 1;
  ctx.strokeRect(barX, barY, barW, barH);

  // Car icon on progress bar
  const carIconX = barX + barW * progress;
  ctx.fillStyle = '#ff4400';
  ctx.fillRect(carIconX - 6, barY - 4, 12, 6);
  ctx.fillStyle = '#ffcc00';
  ctx.fillRect(carIconX - 2, barY - 2, 4, 3);

  // Destination label
  ctx.font = `${Math.max(10, fontSize - 4)}px monospace`;
  ctx.textAlign = 'right';
  ctx.fillStyle = '#aaa';
  const destinations = ['AIRPORT', 'GATE B7', 'BROOKLYN'];
  ctx.fillText(destinations[currentLevel], barX + barW, barY - 4);
  ctx.textAlign = 'left';
  const origins = ['COSTA RICA', 'TERMINAL', 'JFK'];
  ctx.fillText(origins[currentLevel], barX, barY - 4);

  // Boost meter
  const boostW = 80;
  const boostH = 8;
  const boostX = w / 2 - boostW / 2;
  const boostY = barY - 22;

  ctx.font = `${Math.max(9, fontSize - 6)}px monospace`;
  ctx.textAlign = 'center';
  ctx.fillStyle = boosting ? '#ff6600' : '#888';
  ctx.fillText('BOOST', w / 2, boostY - 4);

  ctx.fillStyle = '#222';
  ctx.globalAlpha = 0.6;
  ctx.fillRect(boostX, boostY, boostW, boostH);
  ctx.globalAlpha = 1;

  ctx.fillStyle = boosting ? '#ff4400' : '#ff8800';
  ctx.fillRect(boostX, boostY, boostW * (boostFuel / 100), boostH);
  ctx.strokeStyle = '#555';
  ctx.strokeRect(boostX, boostY, boostW, boostH);

  // Controls hint (first few seconds)
  if (levelTimer < 4) {
    ctx.globalAlpha = Math.max(0, 1 - levelTimer / 4);
    ctx.font = `bold ${Math.max(12, fontSize - 2)}px monospace`;
    ctx.textAlign = 'center';
    ctx.fillStyle = '#ffffff';
    ctx.fillText('TAP / SPACE = JUMP    |    HOLD / 2-FINGER / SHIFT = BOOST', w / 2, h * 0.5);
    ctx.globalAlpha = 1;
  }
}

// ===== GAME OVER / LEVEL COMPLETE =====
function showGameOver(won) {
  const goScreen = document.getElementById('game-over-screen');
  const title = document.getElementById('go-title');
  const stats = document.getElementById('go-stats');
  const tap = document.getElementById('go-tap');

  if (!won) {
    title.textContent = 'CRASHED!';
    title.style.color = '#ff4444';
    stats.innerHTML = `SCORE: ${score}<br>Try again!`;
    tap.textContent = 'TAP TO RETRY';
  } else if (currentLevel < LEVELS.length - 1) {
    title.textContent = 'LEVEL COMPLETE!';
    title.style.color = '#ffcc00';
    const mins = Math.floor(levelTimer / 60);
    const secs = Math.floor(levelTimer % 60);
    stats.innerHTML = `SCORE: ${score}<br>TIME: ${String(mins).padStart(2,'0')}:${String(secs).padStart(2,'0')}`;
    tap.textContent = 'TAP FOR NEXT LEVEL';
  } else {
    title.textContent = 'YOU MADE IT HOME!';
    title.style.color = '#ffcc00';
    const tmins = Math.floor(totalTime / 60);
    const tsecs = Math.floor(totalTime % 60);
    stats.innerHTML = `FINAL SCORE: ${score}<br>TOTAL TIME: ${String(tmins).padStart(2,'0')}:${String(tsecs).padStart(2,'0')}<br><br>Welcome to Brooklyn!`;
    tap.textContent = 'TAP TO PLAY AGAIN';
  }

  goScreen.style.display = 'flex';
}

function showLevelIntro(lvlIndex) {
  const screen = document.getElementById('level-intro');
  document.getElementById('level-title').textContent = LEVELS[lvlIndex].name;
  document.getElementById('level-subtitle').textContent = LEVELS[lvlIndex].subtitle;
  screen.style.display = 'flex';
  gameState = 'levelIntro';
}

// ===== START / TRANSITIONS =====
function startGame() {
  document.getElementById('start-screen').style.display = 'none';
  currentLevel = 0;
  lives = Infinity;
  score = 0;
  totalTime = 0;
  showLevelIntro(0);
}

function startLevel() {
  document.getElementById('level-intro').style.display = 'none';
  document.getElementById('game-over-screen').style.display = 'none';
  initLevel(currentLevel);
  gameState = 'playing';
}

function handleScreenTap() {
  if (gameState === 'start') {
    startGame();
  } else if (gameState === 'levelIntro') {
    startLevel();
  } else if (gameState === 'crashed') {
    document.getElementById('game-over-screen').style.display = 'none';
    // Retry same level
    lives = Infinity;
    score = Math.max(0, score - 100);
    showLevelIntro(currentLevel);
  } else if (gameState === 'levelComplete') {
    document.getElementById('game-over-screen').style.display = 'none';
    currentLevel++;
    showLevelIntro(currentLevel);
  } else if (gameState === 'gameComplete') {
    document.getElementById('game-over-screen').style.display = 'none';
    document.getElementById('start-screen').style.display = 'flex';
    gameState = 'start';
  }
}

document.getElementById('start-screen').addEventListener('click', handleScreenTap);
document.getElementById('start-screen').addEventListener('touchend', e => { e.preventDefault(); handleScreenTap(); });
document.getElementById('level-intro').addEventListener('click', handleScreenTap);
document.getElementById('level-intro').addEventListener('touchend', e => { e.preventDefault(); handleScreenTap(); });
document.getElementById('game-over-screen').addEventListener('click', handleScreenTap);
document.getElementById('game-over-screen').addEventListener('touchend', e => { e.preventDefault(); handleScreenTap(); });

// ===== GAME LOOP =====
let lastTime = 0;

function gameLoop(timestamp) {
  const dt = Math.min(0.05, (timestamp - lastTime) / 1000);
  lastTime = timestamp;

  update(dt);
  render();

  requestAnimationFrame(gameLoop);
}

initLevel(0);
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
